Welcome back. Let's start our journey through the STL design with containers. 

Containers are collections of data in some data structure. Like in the vector example earlier, containers are templated classes. The type of data they contain is a template parameter. This creates a limitation: all data in the container have to be of the same type, we don't have heterogeneous containers, like Python lists for example. While limiting, this is also useful. As we saw earlier, knowing exactly what a vector contains makes it possible to store it and access it efficiently. We can specialise the container for practically any type, built-in and user-defined. That includes other containers too. Each container class implements a different data structure, so each one has a different interface and trade-offs. But they also provide a small number of functions that are common across all containers. This common abstraction is what allows us to use them through generic code.

C++ offers three main categories of containers. Sequence containers, associative containers, and unordered associative containers. We also have two groups of container-like objects: adaptors and views. Finally we have a group of classes that are not exactly containers but they contain data. We will examine each group in more detail soon.

Using a container is relatively straightforward. First, you need to include the appropriate header file, which has the same name as the container. #include vector for example allows us to use vectors. Then later in some other part of the code we declare a variable of type std double-colon vector. std is the standard library namespace, the scope within all these containers live. vector is just the name of the class. Together std vector means the vector class from the standard library.

All containers are templates, so we have to define the template parameters. In this case, we define data as a vector of ints. Similarly, we declare other containers, in this example, a list and a map. These types can be a bit awkward, especially if we need to use them again and again, or if we have multiple template parameters, like we have for map. 

map of int and int means a map structure, a dictionary, translating ints to ints. We can simplify types a bit by declaring our own custom types through the using keyword. This line sets IntToInt to mean std::map of int and int, so when we later declare the translation object, we can describe it as IntToInt.



Okay, all of these containers are useful but I will only go quickly through the most important ones from each container group. You will not need to use in the exam any containers I do not discuss. First, sequence containers store their elements in some short of well defined sequence. vectors, lists, deques, etc.

The most important one is vector. This is similar to the vector we defined earlier. It's a variable size array class and it encapsulates a raw heap array and its size. Like we discussed earlier, this is similar in functionality to Python lists and Java ArrayLists but far more efficient. A pseudo definition is on the right: the class contains a pointer to the heap array and the size of that array.

Its most important vector-specific operations are these: you construct it as an empty vector, with a size, or with a list of elements. You push_back elements to append them and you access specific indexes with square brackets, like you would access an array. You can also access indexes with bounds checking, making sure that the index is valid, using at. This is safer but a bit slower.

The other important container is array. This is a *fixed* size array which encapsulates a raw stack array. The size of the array is a template parameter and known at compile time. Again a pseudo-definition is on the right. std has a similar interface to vector: you can initialise it with a specific space but otherwise empty, you can initialise it with a specific sequence, you can use square brackets and at. The major difference is that you cannot append data, because the array is fixed size. There are more sequence containers but unless you *know* that you need something else, you should just use a vector.

As a matter of fact, you should use vectors even when you think you need a raw array. C-like arrays are somewhere between redundant and harmful in modern C++. Vectors have similar strengths as raw arrays: they provide contiguous storage, direct random access, low storage overhead and low runtime overhead. So vectors can give us the same benefits as C-arrays. But vectors are safer and better. When using at, they eliminate bounds errors, one of the most common runtime errors in C. Then, vectors are resizable, they can grow automatically. They also provide a rich interface to the rest of the library, and they are RAII-compatible.

This last bit is critical. When using raw heap arrays, all the memory management is manual. We have to do a manual new and a manual delete. If we forget the delete, or some exception happens and we skip the delete, then we have a memory leak. This is bad. With vectors, memory management is automatic. We tell the vector what size we want when we create it and it allocates it. Then when the vector goes out of scope, the allocated memory is released.

Finally, C-arrays have the bad habit of decaying into plain pointers when passed to functions. In the function fn1, the typing information alone is not enough to tell whether the argument is an array or a pointer. And if it's an array, we have no way to find its size. When we pass a vector to a function, it remains a vector and its size is still known. This is easier and safer.

There are some corner cases though where a C-array might be more efficient. vectors are dynamically allocated arrays so they carry the same overheads as raw heap arrays. But stack arrays, fixed size arrays, might be slightly faster and more efficient. For example knowing at compile time the size of the array will enable some compiler optimisations making the code faster. 95% of the time you don't care though. And even if you really care, just use the std array which is also a fixed size stack array but does not suffer from the limitations of C-arrays.

Let's move to the next two groups, the associative containers. These implement set and map operations, similarly to the set and dict types in python. The main set-specific operations for set are these: we can create an empty set or initialise it with some elements, we can insert or erase an element, we can find it in the set or count how many times it appears. maps have the same operations but also the square brackets and at operators, which return the value for the given key, the same way these operators return the value for the given index with vectors. 

Both ordered and unordered groups have similar containers with similar interfaces, what differs is the internal implementation. Ordered containers basically keep their data in some kind of order internally. Typically this is done with a search tree. To do that, the data need to be comparable, which means that their class needs to override the comparison operators. Unordered containers store their data in some hash map, so the data type needs to be hashable, it needs to implement a hash operation. For random access, unordered containers are usually faster but they tend to use more memory, so which one to use depends on your problem.

I will skip adaptors and move to Views and the span object. Span is similar to python slices. It's not a true container, it does not have any data of its own, but it encapsulates some memory region with container semantics. We can use it like a container, but the data are in another container. The basic use for spans is to encapsulate C-arrays. If for some reason you still want to use C-arrays or more likely you interface with some C code, you can encapsulate the array with a span and then use it safely. In this example, we declare a stack array a with five elements and we convert it into a span s. We can then directly access any element of a through s but s does not decay into a pointer, carries its size with it, and can do bounds checking.

Finally we have two utility classes that hold data but are not containers: tuples and pairs. They're basically quick and dirty ways for creating ad hoc structs. We will discuss their most important use case next week.

The C++ containers offer a rich interface which allows us to use them efficiently. I will not go through these functions, it would take us ages. And of course you don't need to remember any of this. Just check the reference manual whenever you need to use a container. The thing that you need to remember is that some of these functions are common across all or almost all containers.

This is the common interface of the C++ containers. It's functions retrieving the overall state of the container: empty(), size(), max_size(). It's functions adding items: insert and emplace. It's the erase function which removes a specific item. It's clear which deletes all data.  But most importantly, it's the begin and end functions. These functions allow us to get the beginning and the end of the container, whatever that means for each container. With that information we can then build generic algorithms that can access all items in the container sequentially, from beginning to end. We will discuss this in the next video.

To recap, containers are template classes that encapsulate data organised in some data structure. There are many different containers but you will only need to use a few of them. Almost always what you want is a vector. Vectors make C heap arrays redundant. You get the same performance with cleaner interfaces and better safety. If you think you need a stack array, you could use std array. If you need a dictionary, you could use map or unordered_map. If you need a set, use a set or an unordered set. Spans are not exactly containers but they encapsulate existing memory, for example C arrays, with container semantics. While each container has its own interface, they all share a subset of functions that allows us to use them through generic code.

In the next part, we will discuss an important part of that interface, the handles to the beginning and end of containers, called iterators, and how exactly they allow us to use containers generically.
